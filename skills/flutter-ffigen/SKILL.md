# /flutter-ffigen

Generate Dart FFI bindings from C/C++ header files using ffigen.

## Usage

```
/flutter-ffigen [options]
```

## Options

- `--config <file>`: Config file path (default: ffigen.yaml)
- `--header <file>`: Single header file to generate bindings for
- `--output <file>`: Output Dart file path
- `--init`: Create initial ffigen.yaml configuration

## Examples

```
/flutter-ffigen
/flutter-ffigen --config custom_ffigen.yaml
/flutter-ffigen --header src/my_lib.h --output lib/bindings.dart
/flutter-ffigen --init
```

## Instructions

When the user invokes `/flutter-ffigen`, follow these steps:

### 1. Verify Dependencies

```yaml
# Required in pubspec.yaml
dev_dependencies:
  ffigen: ^11.0.0
```

```bash
# Install if not present
flutter pub add --dev ffigen
flutter pub get
```

### 2. Initialize Configuration (--init)

Create `ffigen.yaml`:

```yaml
# ffigen.yaml
# See https://pub.dev/packages/ffigen for options

name: NativeBindings
description: Generated bindings for native library

output: 'lib/src/bindings/native_bindings.dart'

headers:
  entry-points:
    - 'src/native_lib.h'
  include-directives:
    - 'src/native_lib.h'
    - 'src/types.h'

# Compiler options (platform-specific paths may be needed)
compiler-opts:
  - '-I/usr/local/include'
  # macOS SDK headers
  # - '-I/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include'

# Filter functions to include
functions:
  include:
    - 'native_.*'      # Include all native_ prefixed functions
  exclude:
    - '.*_internal'    # Exclude internal functions
  rename:
    'native_(.*)': '$1'  # Remove prefix in Dart

# Filter structs
structs:
  include:
    - 'Native.*'
  rename:
    'Native(.*)': '$1'

# Filter enums
enums:
  include:
    - 'Native.*'
  member-rename:
    'NATIVE_(.*)': '$1'

# Filter typedefs
typedefs:
  include:
    - 'Native.*'

# Generate doc comments from C comments
comments:
  style: any   # any, doxygen, or none
  length: full # full, brief

# File preamble
preamble: |
  // AUTO-GENERATED - DO NOT EDIT
  // Generated by ffigen
  // ignore_for_file: type=lint
  // ignore_for_file: always_specify_types
  // ignore_for_file: camel_case_types
  // ignore_for_file: non_constant_identifier_names

# Exclude certain declarations
exclude-all-by-default: false

# Use native assets (experimental)
# ffi-native: true

# Symbol file for link-time resolution
# symbol-file:
#   output: 'lib/src/symbols.yaml'
#   import-path: 'package:my_package/src/bindings.dart'
```

### 3. Run ffigen

```bash
# With default config
dart run ffigen

# With custom config
dart run ffigen --config custom_ffigen.yaml

# Verbose output
dart run ffigen --verbose
```

### 4. Handle Platform-Specific Headers

#### macOS

```yaml
compiler-opts:
  # Xcode Command Line Tools
  - '-I/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include'
  # Or Xcode.app
  - '-I/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include'
```

#### Linux

```yaml
compiler-opts:
  - '-I/usr/include'
  - '-I/usr/local/include'
```

#### Windows

```yaml
compiler-opts:
  - '-IC:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt'
```

### 5. Advanced Configuration

#### Type Mappings

```yaml
# Map C types to Dart types
type-map:
  native-types:
    'size_t': 'IntPtr'
    'ssize_t': 'IntPtr'

  typedefs:
    'MyHandle': 'Pointer<Void>'
    'Callback': 'Pointer<NativeFunction<CallbackType>>'
```

#### Struct Dependencies

```yaml
# Ensure dependent types are generated
structs:
  dependency-only:
    - 'InternalStruct'  # Generated but marked @internal
```

#### Opaque Types

```yaml
# Mark types as opaque (pointer-only)
structs:
  opaque:
    - 'OpaqueHandle'
```

#### Function Pointer Typedefs

```yaml
# Generate typedefs for function pointers
functions:
  expose-typedef:
    'callback_type': 'NativeCallbackType'
```

### 6. Generated Code Structure

```dart
// lib/src/bindings/native_bindings.dart (generated)

// ignore_for_file: type=lint
// ignore_for_file: always_specify_types
import 'dart:ffi' as ffi;

/// Bindings for native_lib.h
class NativeBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Adds two integers
  int add(int a, int b) {
    return _add(a, b);
  }

  late final _addPtr = _lookup<ffi.NativeFunction<ffi.Int32 Function(
      ffi.Int32, ffi.Int32)>>('native_add');
  late final _add = _addPtr.asFunction<int Function(int, int)>();

  // ... more generated bindings
}

// Generated structs
final class Point extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;
}
```

### 7. Create Dart Wrapper

```dart
// lib/src/native_lib.dart (manual wrapper)
import 'dart:ffi';
import 'dart:io';
import 'package:ffi/ffi.dart';
import 'bindings/native_bindings.dart';

/// Lazy-loaded native bindings.
late final NativeBindings _bindings;
bool _initialized = false;

/// Initialize the native library.
void initNativeLib() {
  if (_initialized) return;

  final DynamicLibrary dylib;
  if (Platform.isAndroid || Platform.isLinux) {
    dylib = DynamicLibrary.open('libnative_lib.so');
  } else if (Platform.isMacOS) {
    dylib = DynamicLibrary.open('libnative_lib.dylib');
  } else if (Platform.isIOS) {
    dylib = DynamicLibrary.process();
  } else if (Platform.isWindows) {
    dylib = DynamicLibrary.open('native_lib.dll');
  } else {
    throw UnsupportedError('Unsupported platform');
  }

  _bindings = NativeBindings(dylib);
  _initialized = true;
}

/// High-level Dart API
class NativeLib {
  NativeLib() {
    initNativeLib();
  }

  int add(int a, int b) => _bindings.add(a, b);

  String greet(String name) {
    final namePtr = name.toNativeUtf8();
    try {
      final resultPtr = _bindings.greet(namePtr.cast());
      try {
        return resultPtr.cast<Utf8>().toDartString();
      } finally {
        _bindings.freeString(resultPtr);
      }
    } finally {
      calloc.free(namePtr);
    }
  }
}
```

### 8. Incremental Regeneration

When headers change:

```bash
# Regenerate bindings
dart run ffigen

# Update wrapper if API changed
# Then run tests
flutter test
```

### 9. Troubleshooting

#### Header Not Found

```yaml
# Add include paths
compiler-opts:
  - '-I./src'
  - '-I./third_party/include'
```

#### Missing Types

```yaml
# Include dependent headers
headers:
  include-directives:
    - 'src/main.h'
    - 'src/types.h'    # Contains type definitions
```

#### Struct Incomplete

```yaml
# Mark as opaque if definition not needed
structs:
  opaque:
    - 'InternalStruct'
```

### 10. Output Summary

```
ffigen Complete
===============

Config: ffigen.yaml
Output: lib/src/bindings/native_bindings.dart

Generated:
- 15 functions
- 4 structs
- 2 enums
- 3 typedefs

Warnings:
- Skipped function 'internal_func' (excluded by filter)
- Type 'CustomType' mapped to Pointer<Void>

Next Steps:
1. Review generated bindings
2. Create/update Dart wrapper class
3. Test bindings with example code
```

## Agent Reference

For FFI implementation details, consult the `flutter-ffi-native` agent.
